{"version":3,"sources":["initial-data.ts","Task.tsx","Column.tsx","App.tsx","index.tsx"],"names":["initialData","tasks","id","content","columns","title","taskIds","columnOrder","Container","styled","div","isCurrentlyDragging","Task","task","indexForDraggable","draggableId","index","provided","snapshot","draggableProps","dragHandleProps","ref","innerRef","isDragging","Title","h3","TaskList","isAnyItemDraggingOverTaskList","Column","column","droppableId","probided","snapschot","droppableProps","isDraggingOver","map","item","placeholder","App","useState","data","setData","onDragEnd","result","destination","source","startColumn","finishColumn","newTaskIds","Array","from","splice","newColumn","newState","newStartColumnTaskIds","newStartColumn","newFinishColumnTaskIds","newFinishColumn","columnId","columnIndex","taskId","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f53052c8.chunk.js","sourcesContent":["export interface Column {\r\n  id: string;\r\n  title: string;\r\n  taskIds: string[];\r\n}\r\n\r\nexport interface Task {\r\n  id: string;\r\n  content: string;\r\n}\r\n\r\nexport interface InitialData {\r\n  tasks: {\r\n    [key: string]: Task;\r\n  };\r\n  columns: {\r\n    [key: string]: Column;\r\n  };\r\n  columnOrder: string[];\r\n}\r\n\r\nexport const initialData: InitialData = {\r\n  tasks: {\r\n    \"task-1\": {\r\n      id: \"task-1\",\r\n      content: \"Take out the garbage\",\r\n    },\r\n    \"task-2\": {\r\n      id: \"task-2\",\r\n      content: \"Watch my favorite show\",\r\n    },\r\n    \"task-3\": {\r\n      id: \"task-3\",\r\n      content: \"charge my phone\",\r\n    },\r\n    \"task-4\": {\r\n      id: \"task-4\",\r\n      content: \"cook dinner\",\r\n    },\r\n  },\r\n  columns: {\r\n    \"column-1\": {\r\n      id: \"column-1\",\r\n      title: \"to do\",\r\n      taskIds: [\"task-1\", \"task-2\", \"task-3\", \"task-4\"],\r\n    },\r\n    \"column-2\": {\r\n      id: \"column-2\",\r\n      title: \"In progress\",\r\n      taskIds: [],\r\n    },\r\n    \"column-3\": {\r\n      id: \"column-3\",\r\n      title: \"Done\",\r\n      taskIds: [],\r\n    },\r\n  },\r\n  columnOrder: [\"column-1\", \"column-2\", \"column-3\"],\r\n};\r\n","import { Task as ITask } from \"initial-data\";\r\nimport styled from \"styled-components\";\r\nimport {\r\n  Draggable,\r\n  DraggableStateSnapshot,\r\n  // DroppableStateSnapshot,\r\n} from \"react-beautiful-dnd\";\r\n\r\n// w snapshot: DraggableStateSnapshot ten argument snapschot zawiera rózne informacje dotyczące obecnie przesuwanego elementu np isDragging, albo draggingOver czyli czy jest przesuwany oraz nad jaki element obecnie najeżdza\r\n\r\n// przykład:\r\n\r\n// --- poniższy element to jest ten użyty ponieważ Task.tsx ma Draggable provider\r\n// const snapschot: DraggableStateSnapshot = {\r\n//   isDragging: false,\r\n//   draggingOver: \"column-1\",\r\n// };\r\n\r\n// const droppableSnapschot: DroppableStateSnapshot = {\r\n//   isDraggingOver: true,\r\n//   draggingOverWith: \"task-1\",\r\n// };\r\n\r\ninterface TaskProps {\r\n  task: ITask;\r\n  indexForDraggable: number;\r\n}\r\n\r\nconst Container = styled.div<{ isCurrentlyDragging: boolean }>`\r\n  border: 1px solid lightgrey;\r\n  border-radius: 2px;\r\n  padding: 8px;\r\n  margin-bottom: 9px;\r\n  display: flex;\r\n  background-color: ${({ isCurrentlyDragging }) =>\r\n    isCurrentlyDragging ? \"lightgreen\" : \"white\"};\r\n`;\r\n\r\n// const Handle = styled.div`\r\n//   width: 20px;\r\n//   height: 20px;\r\n//   background-color: orange;\r\n//   border-radius: 4px;\r\n//   margin-right: 8px;\r\n// `;\r\n\r\nconst Task = ({ task, indexForDraggable }: TaskProps) => {\r\n  return (\r\n    <Draggable draggableId={task.id} index={indexForDraggable}>\r\n      {(provided, snapshot: DraggableStateSnapshot) => (\r\n        <Container\r\n          {...provided.draggableProps} // pozwalają na bycie przesuwanym przez element który ma dragHandleProps\r\n          {...provided.dragHandleProps} // pozwalają na złapanie elementu i przesuwanie elementem który ma draggableProps\r\n          ref={provided.innerRef}\r\n          isCurrentlyDragging={snapshot.isDragging}\r\n        >\r\n          {/* <Handle {...provided.dragHandleProps} /> */}\r\n          {task.content}\r\n        </Container>\r\n      )}\r\n    </Draggable>\r\n  );\r\n};\r\n\r\nexport default Task;\r\n","import { Column as IColumn, Task as ITask } from \"initial-data\";\r\nimport styled from \"styled-components\";\r\n\r\nimport { Droppable, DroppableStateSnapshot } from \"react-beautiful-dnd\";\r\n\r\n// w snapshot: DraggableStateSnapshot ten argument snapschot zawiera rózne informacje dotyczące obecnie przesuwanego elementu np isDragging, albo draggingOver czyli czy jest przesuwany oraz nad jaki element obecnie najeżdza\r\n\r\n// przykład:\r\n\r\n// const snapschot: DraggableStateSnapshot = {\r\n//   isDragging: false,\r\n//   draggingOver: \"column-1\",\r\n// };\r\n\r\n// --- poniższy element to jest ten użyty ponieważ Task.tsx ma Draggable provider\r\n// const droppableSnapschot: DroppableStateSnapshot = {\r\n//   isDraggingOver: true,\r\n//   draggingOverWith: \"task-1\",\r\n// };\r\n\r\nimport Task from \"./Task\";\r\n\r\nexport interface ColumnProps {\r\n  column: IColumn;\r\n  tasks: ITask[];\r\n}\r\n\r\nconst Container = styled.div`\r\n  margin: 8px;\r\n  border: 1px solid lightgrey;\r\n  border-radius: 2px;\r\n  min-width: 220px;\r\n\r\n  display: flex; // ważne, ponieważ trzeba nadać TaskList jakaś wysokość i najlepiej jest dać mu flex-grow, dlatego tutaj flex\r\n  flex-direction: column;\r\n`;\r\nconst Title = styled.h3`\r\n  padding: 8px;\r\n`;\r\nconst TaskList = styled.div<{ isAnyItemDraggingOverTaskList: boolean }>`\r\n  padding: 8px;\r\n  transition: background-color 0.2s ease;\r\n  background-color: ${({ isAnyItemDraggingOverTaskList }) =>\r\n    isAnyItemDraggingOverTaskList ? \"skyblue\" : \"white\"};\r\n\r\n  flex-grow: 1; // nadajemy flex-grow aby ten element miał zawsze max dostepną wysokość bo to on ma droppableProps i ref i to w nim można umieszczać elementy\r\n  min-height: 100px; // ważne, w przypadku jakby w kolumnie nie było żadnych elementów to TaskList miałby wysokosć 0 więc nie dałoby się do niego dodać żadnego tasku dlatego trzeba dodac jakąś minimalną wysokość\r\n`;\r\n\r\nconst Column = ({ column, tasks }: ColumnProps) => {\r\n  return (\r\n    <Container>\r\n      <Title>{column.title}</Title>\r\n      <Droppable droppableId={column.id}>\r\n        {(probided, snapschot: DroppableStateSnapshot) => (\r\n          <TaskList\r\n            ref={probided.innerRef}\r\n            {...probided.droppableProps}\r\n            isAnyItemDraggingOverTaskList={snapschot.isDraggingOver}\r\n          >\r\n            {tasks.map((item, index) => (\r\n              <Task key={item.id} task={item} indexForDraggable={index} />\r\n            ))}\r\n            {probided.placeholder}\r\n          </TaskList>\r\n        )}\r\n      </Droppable>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport default Column;\r\n","import { useState } from \"react\";\r\nimport { initialData, Column as IColumn, InitialData } from \"./initial-data\";\r\n\r\nimport Column from \"./Column\";\r\n\r\nimport { DragDropContext, DropResult } from \"react-beautiful-dnd\";\r\nimport styled from \"styled-components\";\r\n\r\nconst Container = styled.div`\r\n  display: flex;\r\n`;\r\n\r\nfunction App() {\r\n  const [data, setData] = useState(initialData);\r\n\r\n  const onDragEnd = (result: DropResult) => {\r\n    const { destination, source, draggableId } = result;\r\n\r\n    // destipation może czasami być undefined lub null w przypadku jak np ktoś upuścił poza obszarem Droppable\r\n    if (!destination) return;\r\n\r\n    // sprawdzenie czy po upuszczeniu przesuwanego elementu zmieniła się jego pozysja (czy zmienił się droppable Area lub czy zmieniła się kolejność wewnątrz tej samej droppable area)\r\n    if (\r\n      destination.droppableId === source.droppableId &&\r\n      destination.index === source.index\r\n    )\r\n      return; // jak się nie zmieniła to nic nie robimy bo po co\r\n\r\n    const startColumn = data.columns[source.droppableId];\r\n    const finishColumn = data.columns[destination.droppableId];\r\n\r\n    // jesli zmieniamy kolejność ale w obrębie tej samej kolumny:\r\n    if (startColumn === finishColumn) {\r\n      const newTaskIds = Array.from(startColumn.taskIds);\r\n      newTaskIds.splice(source.index, 1);\r\n      newTaskIds.splice(destination.index, 0, draggableId); //na tablicy newTaskIds od destination.index indexu, nic nie usuwa, tylko dodaje\r\n\r\n      // tworzymy nową (zupdate'owaną) columnę\r\n      const newColumn: IColumn = {\r\n        ...startColumn,\r\n        taskIds: newTaskIds, //  jedynie podmieniamy tablicę z id'kami tasków (żeby po upuszczeniu faktycznie zmieniła się kolejność)\r\n      };\r\n\r\n      // robimy update state\r\n      const newState: InitialData = {\r\n        ...data,\r\n        columns: {\r\n          ...data.columns,\r\n          [newColumn.id]: newColumn, // tak na prawdę to jedynie podmieniamy columnę na której ktoś zrobił drag-n-drop\r\n        },\r\n      };\r\n\r\n      setData(newState);\r\n    } else {\r\n      // jeśli zmieniliśmy kolumnę:\r\n\r\n      // -------- update kolumny z której zaczęto przesuwać element\r\n      const newStartColumnTaskIds = Array.from(startColumn.taskIds);\r\n      newStartColumnTaskIds.splice(source.index, 1);\r\n\r\n      const newStartColumn: IColumn = {\r\n        ...startColumn,\r\n        taskIds: newStartColumnTaskIds,\r\n      };\r\n\r\n      // -------- update kolumny do której upuszczono element\r\n      const newFinishColumnTaskIds = Array.from(finishColumn.taskIds);\r\n      newFinishColumnTaskIds.splice(destination.index, 0, draggableId);\r\n\r\n      const newFinishColumn: IColumn = {\r\n        ...finishColumn,\r\n        taskIds: newFinishColumnTaskIds,\r\n      };\r\n\r\n      // -------- zapisanie state z nowymi kolumnami\r\n      const newState: InitialData = {\r\n        ...data,\r\n        columns: {\r\n          ...data.columns,\r\n          [newStartColumn.id]: newStartColumn,\r\n          [newFinishColumn.id]: newFinishColumn,\r\n        },\r\n      };\r\n\r\n      setData(newState);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <DragDropContext\r\n      //  onDragStart={} // another avaliable methods, but they are not required\r\n      //  onDragUpdate={} // another avaliable methods, but they are not required\r\n      onDragEnd={onDragEnd}\r\n    >\r\n      <Container>\r\n        {data.columnOrder.map((columnId, columnIndex) => {\r\n          const column = data.columns[columnId];\r\n          const tasks = column.taskIds.map((taskId) => data.tasks[taskId]);\r\n\r\n          return <Column key={column.id} column={column} tasks={tasks} />;\r\n        })}\r\n      </Container>\r\n    </DragDropContext>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport App from \"./App\";\r\nimport \"@atlaskit/css-reset\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}